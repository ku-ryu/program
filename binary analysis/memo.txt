ハッシュ化
    stringsコマンドでパスワードが抜かれないように、パスワードを
    暗号化したものをプログラムに埋め込み、入力された文字に暗号化
    を施し一致するかどうかを調べる方法

ビッグエンディアン
    アドレスの小さい方に情報を上の桁から書き込んでいく書き方

リトルエンディアン
    アドレスの小さい方に下の桁から書き込んでいく書き方
    一般的にリトルエンディアンで動作する

int32_t
    stdint.hをインクルードすることで使える
    符号あり32bit整数型

ESP,EBP
    スタックデータ構造の一番上をtop、一番下をbottomと呼ぶ
    それぞれアドレスで位置を示す事ができる　それをポインタと呼ぶ
    ESP(Extended Stack Pointer:スタックポインタ)
    EBP(Extended Base Pointer:ベースポインタ)

アドレス値(新しいデータをPushした時)
    アドレスの大きい方がスタックの古い方
    アドレスの小さい方がスタックの新しい方
    ポインタは足すと古い方向、引くと新しい方向

標準入力のアドレス値
    入力した順にアドレスの小さい方から大きい方へと
    書き込まれる
    →あらかじめスタックを確保する必要がある
    そのスペースのことをバッファ(buffer)という

バッファオーバーフロー
    確保しておいたバッファ以上に入力されると、スタックの古いデータ
    が上書きされる

-fno-stack-protector
    gccでコンパイルする際セキュリティ機能をオフにするコマンド

Segmentation fault
    EBPを超えて入力で上書きされることで発生するエラー

strcmp
    引数に与えられた2つの文字列が一致するとき0を返す

スタック保護
    コンパイルする際、バッファオーバーフロー脆弱性が発生しないよう
    な機能を組み込んでコンパイルする

fgets関数
    バッファ以上の入力を受け付けない
    引数に読み込むサイズを指定出来る

汎用レジスタ
    用途が決められていないレジスタ
    EAX(アキュームレータレジスタ)：返り値
    EBX(ベースレジスタ)：アドレスのベース値
    ECX(カウンタレジスタ)：ループの回数のカウントなど
    EDX(データレジスタ)：演算に用いるデータ

    頭文字のEは32ビット仕様を示す
    64ビットの場合は頭文字がRになる

特殊レジスタ
    特有の用途がある
    ESP(スタックポインタ)：実行中の関数のスタックのトップを
    常に指す
    EBP(スタックベースポインタ)：実行中の関数のスタックのボトムを
    常に指す
    EIP(インストラクションポインタ)：メモリのプログラム部の、次に
    実行する命令のアドレスを常に格納している

フラグレジスタ
    命令や演算の実行結果として生じた状態を保存したレジスタ
    値によって条件付き分岐命令の分岐先が決定する

cmp命令
    フラグレジスタを更新

je命令
    ジャンプ命令

オペコード、オペランド
    mov eax, 0
    movがオペコード　どんな操作をするか指定
    eax 0がオペランド　操作の対象を指定
    →eax 上書き対象　ディスティネーションオペランド
     0 操作の情報源になる対象　ソースオペランド

ポインタの参照先へのアクセス
    EBXがポインタでEBXの中に格納されているアドレスにEAXの中身を
    書き込む場合
    Intel記法 mov [ebx], eax
    AT&T記法 mov %eax, (%ebx)

mov：代入 add：足す sub：引く

push (ASCIIコード)
    Hiをpushする時、H(0x48),i(0x69)なので push 0x6948とする
    リトルエンディアンなので、順番を入れ替える必要あり

ジャンプ命令
    jmp dest ：常にdestにジャンプする
    jz  dest ：ゼロフラグのビットが1の時destにジャンプする
    jnz dest ：ゼロフラグのビットが0の時destにジャンプする
    
mov DWORD PRT [ebp-0xd], 0x66656562
    ebpの指すアドレスから16進数で0xdだけ減らした場所に
    0x66656562をコピーする

sub 引き算